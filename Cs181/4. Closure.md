break down into simpler problems, solve these problems and invoke (envoke?) closure property. 
(side note for future, i forgot my glasses so relied on pics for notes lol)

## 4.1 Complement operation 

complement of a set 
![[Drawing 2025-04-09 14.50.30.excalidraw]]

s bar = { x: x ∉ s}

then L regular -> Lbar regular 

![[IMG_9932.jpg]]![[IMG_9933.jpg]]

(in the past we had 


ex: {w: w contains 0101}

![[Drawing 2025-04-02 14.34.59.excalidraw]]

but this is the negative of that )![[IMG_9934.jpg]]


## 4.2 union + intersection  

![[IMG_9935.jpg]]
![[IMG_9936.jpg]]![[IMG_9938.jpg]]

### cartesian product construction (really important!!!) 
![[IMG_9939.jpg]]


### closure recap 
regular langs are closed under a given operation if applying that operation to reg languages always results in a regular language 

L' ⊕ L" = (L'∩L" )∪(L"∩ L'_ )

# 4.3 set difference 
![[Drawing 2025-04-14 14.14.15.excalidraw]]

L', L" = {w ∈ L'; w ∉ L"}

then L', L" reg => L' \ L" reg.

proof L'\L'' = L' ∩ L"

![[Drawing 2025-04-14 14.17.05.excalidraw]]

Prob: If L', L'' regular so is L = {w∈ L': no substring of w is in L'' }


reworded 

if A, B regular so is L = {w∈ A: no substring of w is in B}

A = available
B = bad

for instance at DMV A is valid allowed licesne plates and B are taken or no allowed 

B' = strings that contain a substring in B 

![[Drawing 2025-04-14 14.23.09.excalidraw]]

we added the start state outside of the cloud to allow us to remove prefixes 
nfa for B  in black 

nfa for B' in red



## 4.4 concatenation 

Def: 
L' L" = { w' w ": w' ∈L'., w'' ∈ L'' }

(also denoted with a circle around L' L'' or L' (some symbol maybe a dot) L'')

ex L' {000,111} L'' = {10,010}
L' L'' {00010,000010, 11110, 111010}

ex  L ∅ = ∅
L {ε} = L 
∅ L = ∅
{ε} L = L 

therom 
L', L'' reg -> L' L'' 

![[Drawing 2025-04-14 14.36.35.excalidraw]]
add an  ε accept arrow from each accept state of first NFA to q''0

then make all states of first nfa reject 

![[Drawing 2025-04-14 14.42.00.excalidraw]]

ex L = { u v : } |u| add, v contains >= 2 zeros

![[Drawing 2025-04-14 14.45.46.excalidraw]]

## 4.3 Kleene star 

Def: 
`L*` = {w: w is the concatenation of ZERO or more strings in L}

Def 
L = {0,1}
`L*` = {ε,0,1,00,01,10,11,...} all binary strings 

Observation 
`∅*` = {ε}
`{ε}*` = {ε}

Observation: 
`L*` finite (=)
L = ∅ or L = {ε}

therom L reg => 
`L* `reg 

_incorrect proof_
`L*` = {ε} ∪ L ∪ LL ∪ LLL ∪ LLLL ∪... 

can say ε is reg, L is reg, LL is reg, LLL is 