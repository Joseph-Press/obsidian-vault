
# 2.1 basic notions

steps: 
- choose an alphabet : {a,b}
- draw states
- choose start state
- choose accept states
- draw transitions
	- a state may have 0 or 1 or 2 ... transitions on a given symbol
	- may have transitions on empty (Îµ)
	![[Drawing 2025-04-02 15.11.47.excalidraw]]lang = strings containing 11 or 101
NFA accepts w if and only if there is at least one path to an accepted state

| input  | path       | output |
| ------ | ---------- | ------ |
| Îµ      | -          | reject |
| 0      | -          | reject |
| 1      | -          | reject |
| 010110 | AABCDDD    | accept |
| 010    | a->a->b->c | reject |
# 2.2 using shortcuts 

ex: âˆ…
![[Drawing 2025-04-02 15.30.14.excalidraw]]
ex: {Îµ}
![[Drawing 2025-04-02 15.30.38.excalidraw]]
ex: {w: w doesnt contain a 1}
![[Drawing 2025-04-02 15.32.49.excalidraw]]
ex: {w: |w| >= 2 and w stays starts and ends with a 0}
![[Drawing 2025-04-02 15.33.56.excalidraw]]

# 2.3 pattern matching 

alphabet = {0,1 }

ex { wi contains 0101}

![[Drawing 2025-04-02 15.41.54.excalidraw]]
![[IMG_9866.jpg]]

# 2.4 alternatives 
ex {w: |w| is divisible by 2 or by 3}

or is the operative word here ( can split lang into 2 langs that are easier to understand and combine solutions for complete solution)

![[Drawing 2025-04-02 15.50.33.excalidraw]]


# 2.4 continued

ex: {w: w contains an even # of 0s or exactly two 1s}

decompose into two simpler problems bc of the or 

![[Drawing 2025-04-07 14.06.22.excalidraw]]

ex: {w: w doesnt contain both 0,1}
![[Drawing 2025-04-07 14.10.46.excalidraw]]

# 2.5 formal definitions
Def: An NFA is a tuple  (Q,Î£,Î´,q0,F)  where 
-  **Q**: A finite set of states (nonempty + finite).
    
- **Î£**: A finite set of symbols, known as the alphabet (nonempty, finite).
    
- **q0**: The start state, where q0âˆˆQ
    
- **F**: The set of accepting (or final) states, where FâŠ†Q
  
  so far the same as dfas ^

- **Î´**: The transition function,
	- chat gpt addition mapping each state and input symbol pair to a single next state. Formally, Î´:QÃ—Î£â†’Q This means that for every state qâˆˆQ and input symbol aâˆˆÎ£, Î´(q,a) specifies the next state. 
	- in class Î´: QÃ—( Î£ union {Îµ}) -> Q 
		- epsilon isnt a set its an element
		- Q current state
		- ( Î£ union {Îµ}) what we're transitioning on
		- -> Q next state s()
			- but Q here is incorrect it's actually ğ’«(Q) (powerset of Q is next state)
	ğ’«(({1,2,3})={âˆ…,{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}
		
	a,b,c,d..
	A,B,C,D,E..
	ğ’œ, â„¬, ğ’, ğ’Ÿ, â„°, â„±, ğ’¢, â„‹, â„, ğ’¥, ğ’¦, â„’, â„³, ğ’©, ğ’ª, ğ’«, ğ’¬, â„›, ğ’®, ğ’¯, ğ’°, ğ’±, ğ’², ğ’³, ğ’´, ğ’µ
	made by Palmer


ex: 
![[Drawing 2025-04-07 14.29.55.excalidraw]]
({A,B,C,D}), {0,1},**Î´**,A,{D}}
A is start state D is end sates 
**Î´**:

|     | 0   | 1     | Îµ                     |
| --- | --- | ----- | --------------------- |
| A   | {A} | {A,B} | âˆ… or actually {A}     |
| B   | {C} | âˆ…     | {C} or actually {B,C} |
| C   | âˆ…   | {D}   | âˆ… or actually {C}     |
| D   | {D} | {D}   | âˆ… or actually {D}     |

Ex:
({A,B,C}, {0,1},**Î´**,A,{B})
![[Drawing 2025-04-07 14.38.16.excalidraw]]

|     | 0   | 1     | Îµ   |
| --- | --- | ----- | --- |
| A   | {C} | {B}   | âˆ…   |
| B   | {A} | âˆ…     | âˆ…   |
| C   | {B} | {B,C} | {A} |




Def: NFA (Q,Î£,Î´,q0,F) accepts w iffi  :
![[IMG_9909.jpg]]
Ïƒ0, Ïƒ1,Ïƒ2,Ïƒ3, ...Ïƒm-1 = W 


Îµ001ÎµÎµÎµ1Îµ1Îµ = 00111


Def: NFA N=(Q,Î£,Î´,q0,F) recognizes the lang L if and only if L = {w: N accepts w} 
	recognizes is poor term according to prof, computes might be better word